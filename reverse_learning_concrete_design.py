# -*- coding: utf-8 -*-
"""Reverse Learning Concrete Design

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fyyg1mvDLW55jJfUcsxBa3jAQiC8nkLY
"""

import numpy as np
import pandas as pd
import seaborn as sn

from sklearn.model_selection import train_test_split
from sklearn.metrics import max_error
from sklearn.metrics import r2_score

from sklearn.ensemble import RandomForestRegressor as rfr

pip install -U pymoo

#Evaluaate Performance
def test(model1, X_test, y_test):
  print(model1)
  print("")
  r1 = model1.predict(X_test)
  print("prediction 1:\n", r1)

  print("")
  #Score:
  print("Score for prediction")
  print("R square score:", r2_score(y_test, r1))
  print("Max error:", max_error(y_test, r1))
  print("")
  print("-------------------------------------")

rs = 5138

data = pd.read_csv('/content/TestData.csv')
data.head(2)

def fraction_df(data):
  datfr = pd.DataFrame()
  datfr['C/B'] = data['CaO']/data['Total Binder']
  datfr['S/B'] = data['SiO']/data['Total Binder']
  datfr['H/B'] = data['H20']/data['Total Binder']
  datfr['A/B'] = (data['Na2O']+data['K2O'])/data['Total Binder']
  datfr['F/T'] = data['FA']/(data['FA']+data['CA'])
  datfr['C/T'] = data['CA']/(data['FA']+data['CA'])

  return datfr

def f_val_min_max(data, features:list, change_pc=0):
  '''function to get the minimum and maximum value of a feature'''
  n_f = len(features)
  min_reduce = 1-change_pc/100
  max_increase = 1+change_pc/100
  min_vals = []
  max_vals = []
  for i in range(n_f):
    min_vals.append(min_reduce*min(data[features[i]]))
    max_vals.append(max_increase*max(data[features[i]]))

  return min_vals, max_vals

dat = fraction_df(data)
datfr = pd.concat([dat, data['DRCM'], data['Strength']], axis = 1)

data1 = datfr[['C/B', 'S/B', 'H/B', 'A/B', 'F/T', 'C/T', 'DRCM']]
data2 = datfr[['C/B', 'S/B', 'H/B', 'A/B', 'F/T', 'C/T','Strength']]
features = ['CaO', 'SiO', 'Na2O', 'K2O', 'H20', 'FA', 'CA', 'Total Binder']
n_f = len(features)

#Diffusion Coefficient Split
output_d = ['DRCM']
Input_d = ['C/B', 'S/B', 'H/B', 'A/B', 'F/T', 'C/T']

Xd = data1[Input_d]
yd = data1[output_d]

D_train, D_test, yd_train, yd_test = train_test_split(Xd, yd, random_state = rs)

#Diffusion Coefficient Train
rfr_d = rfr(max_depth = 12)#, min_samples_split=4, n_estimators=66, random_state=rs)
rfr_d.fit(D_train, yd_train)

test(rfr_d, D_test, yd_test)

r = rfr_d.predict(D_test)
s = np.array(yd_test["DRCM"])
l = []
for i in r:
  l.append(float(i))

abs(s - np.array(l))/s*100

#Strength Split
output_s = ['Strength']
Input_s = ['C/B', 'S/B', 'H/B', 'A/B', 'F/T', 'C/T']

Xs = data2[Input_s]
ys = data2[output_s]

S_train, S_test, ys_train, ys_test = train_test_split(Xs, ys, random_state = rs)

#Strength Train
rfr_s = rfr(max_depth = 30)#12, n_estimators=106, min_samples_split=4, random_state=rs)
rfr_s.fit(S_train, ys_train)

test(rfr_s, S_test, ys_test)

r = rfr_s.predict(S_test)
s = np.array(ys_test['Strength'])
l = []
for i in r:
  l.append(float(i))

abs(s - np.array(l))/s*100

def predict(model, X):
  td = pd.DataFrame(X, columns = features)
  tp = fraction_df(td)
  r = model.predict(tp)
  return r

a = [3.79414979e+02, 1.37046136e+02, 8.96115747e-01, 5.69255123e+00, 2.01175068e+02, 6.37779876e+02, 1.12112352e+03, 6.03947398e+02]

predict(rfr_s, [a])

def mass_of_material(M_CaO, M_SiO2, M_K2O, fa=True, s=True):

  if fa==False:
    mass = [M_CaO, M_SiO2]
    Cmax = [np.array([65.59, 48.59]),np.array([19.59, 32.59/100])]   #Cement, Slag
  elif s==False:
    mass = [M_CaO, M_SiO2]
    Cmax = ([np.array([65.59, 1.44])/100, np.array([19.59, 62.75])/100])   #Cement, Flyash
  else:
    mass = [M_CaO, M_SiO2, M_K2O]
    Cmax = [np.array([65.59, 1.44, 48.59])/100 ,np.array([19.59, 62.75, 32.59])/100, np.array([0.57, 2.65, 0.38])/100]   #Cement, Flyash, Slag

  mass_m = np.linalg.solve(Cmax, mass)
  return mass_m

tdc = 4.9#4.51
tstr = 51#43.2
wc_ratio = 0.35

from pymoo.core.problem import ElementwiseProblem

class functions(ElementwiseProblem):

    def __init__(self):
        super().__init__(n_var=n_f,
                         n_obj=2,
                         n_ieq_constr=1,
                         n_eq_constr=0,
                         #'CaO', 'SiO', 'Na2O', 'K2O', 'H20', 'FA', 'CA', 'Total Binder'
                         xl = f_val_min_max(data, features, change_pc=2)[0],
                         xu = f_val_min_max(data, features, change_pc=2)[1]
                         )


    def _evaluate(self, x, out, *args, **kwargs):

        Xt = []

        for i in range(n_f):
          Xt.append(x[i])

        f1 = abs(predict(rfr_d, [Xt]) - tdc)
        f2 = abs(predict(rfr_s, [Xt]) - tstr)

        g1 = x[7] - np.sum(mass_of_material(x[0], x[1], x[3], fa=True, s=True))
        #g2 = -(x[4]/x[7] - 0.99*wc_ratio)
        #g3 = (x[4]/x[7] - 1.01*wc_ratio)

        out["F"] = [f1, f2]
        out["G"] = [g1]#g2, g3]

problem = functions()

from pymoo.algorithms.moo.nsga2 import NSGA2
from pymoo.operators.crossover.sbx import SBX
from pymoo.operators.mutation.pm import PM
from pymoo.operators.sampling.rnd import FloatRandomSampling

algorithm = NSGA2(
    pop_size=50,
    n_offsprings=30,
    sampling=FloatRandomSampling(),
    crossover=SBX(prob=0.7, eta=5),
    mutation=PM(eta=5),
    eliminate_duplicates=True
)

from pymoo.termination import get_termination

termination = get_termination("n_gen", 50)

from pymoo.optimize import minimize

res = minimize(problem,
               algorithm,
               termination,
               seed=rs,
               save_history=True,
               verbose=True)

X = res.X
F = res.F

X

F

def select(F, X):
  x = [i[0] for i in F]
  y = [i[1] for i in F]
  close_val = abs(45 - np.arctan((np.array(y)/tstr)/(np.array(x)/tdc))*360/np.pi/2)
  close_val = list(close_val)
  indx = close_val.index(min(close_val))
  return X[indx]

select(F, X)

